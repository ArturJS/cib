<!doctype html>
<html lang="en-us">

<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Clang In Browser</title>
    <style>
        .hidden {
            display: none;
        }

        .process {
            overflow: hidden;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        #clang-format-result {
            flex-grow: 5;
            overflow: hidden;
        }

        .io {
            overflow: auto;
            margin: 0;
            flex-grow: 5;
            background-color: black;
            color: white;
            font-family: 'Lucida Console', Monaco, monospace;
            white-space: pre-wrap;
        }

        .controls {
            margin: 4px;
        }

        .controls-border {
            padding-bottom: 2px;
            border-bottom: 1px solid black;
        }

        .right-button {
            float: right;
        }

        #pane-source {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div class="hidden">
        <div id="pane-clang" class="process">
            <div class="controls">
                <button id="clang-run" onclick="compile()">Compile</button>
                <button id="clang-save" onclick="saveWasm()">Save</button>
                <span id="clang-status"></span>
                <button id="clang-reboot" class="right-button" onclick="clang.reboot()">Reboot</button>
            </div>
            <pre id="clang-io" class="io"></pre>
        </div>
        <div id="pane-clang-format" class="process split split-horizontal">
            <div class="controls controls-border">
                clang-format:
                <span id="clang-format-status"></span>
                <button id="clang-format-reboot" class="right-button" onclick="rebootClangFormat()">Reboot</button>
            </div>
            <div id="clang-format-result"></div>
        </div>
        <div id="pane-runtime" class="process split split-horizontal">
            <div class="controls">
                <button id="runtime-run" onclick="run()">Run</button>
                <span id="runtime-status"></span>
                <button id="runtime-reboot" class="right-button" onclick="runtime.reboot()">Reboot</button>
            </div>
            <pre id="runtime-io" class="io"></pre>
        </div>
    </div>

    <link rel="stylesheet" type="text/css" href="golden-layout/goldenlayout-base.css" />
    <link rel="stylesheet" type="text/css" href="golden-layout/goldenlayout-light-theme.css" />
    <script src="jquery-1.11.1.min.js"></script>
    <script src="golden-layout/goldenlayout.min.js"></script>
    <script src="monaco-editor/min/vs/loader.js"></script>
    <script type='text/javascript' src='process-manager.js'></script>
    <script type='text/javascript'>
        let exampleCode = `// clang runs in the browser and compiles C++
// to WebAssembly, which the browser then runs.
// See https://github.com/tbfleming/cib for known issues.

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

struct S {
    S() {cout << "Constructed before main()\\n";};
} s;

int main() {
    auto strs = vector{"3"s, "2"s, "1"s, "4"s, "but this demo is real."s, "The 🍰 is a lie,"s};
    sort(begin(strs), end(strs));
    for (auto s: strs)
        cout << s << "\\n";
}
`

        let layoutConfig = {
            settings: {
                showPopoutIcon: false,
                showCloseIcon: false,
            },
            content: [{
                type: 'row',
                content: [{
                    type: 'column',
                    content: [{
                        type: 'component',
                        title: 'Source',
                        isClosable: false,
                        componentName: 'component',
                        componentState: { id: 'pane-source' }
                    }, {
                        type: 'component',
                        title: 'clang',
                        isClosable: false,
                        componentName: 'component',
                        componentState: { id: 'pane-clang' }
                    }]
                }, {
                    type: 'column',
                    content: [{
                        type: 'component',
                        title: 'clang-format',
                        isClosable: false,
                        componentName: 'component',
                        componentState: { id: 'pane-clang-format' }
                    }, {
                        type: 'component',
                        title: 'Output',
                        isClosable: false,
                        componentName: 'component',
                        componentState: { id: 'pane-runtime' }
                    }]
                }]
            }]
        };

        let layout = new GoldenLayout(layoutConfig);
        layout.registerComponent('component', function (container, state) {
            let child = document.getElementById(state.id);
            if (!child) {
                child = document.createElement('div');
                child.className = state.className;
                child.id = state.id;
            }
            container.getElement().get(0).appendChild(child);
        });
        layout.init();

        let editor;
        let formatEditor;
        let editorContent = exampleCode;
        let prevEditorContent = '';

        require.config({ paths: { 'vs': 'monaco-editor/min/vs' } });
        require(['vs/editor/editor.main'], function () {
            editor = monaco.editor.create(document.getElementById('pane-source'), {
                value: exampleCode,
                language: 'cpp',
                automaticLayout: true,
            });
            formatEditor = monaco.editor.create(document.getElementById('clang-format-result'), {
                language: 'cpp',
                automaticLayout: true,
                readOnly: true,
            });

            let changeTimer = -1;
            function codeChanged() {
                changeTimer = -1;
                editorContent = editor.getValue();
                updateUI();
            }
            editor.onDidChangeModelContent(e => {
                if (changeTimer !== -1)
                    clearTimeout(changeTimer);
                changeTimer = setTimeout(codeChanged, 100);
            });

            updateUI();
        });

        class ProcessUI {
            constructor(name) {
                this.name = name;
                this.runButton = document.getElementById(name + '-run');
                this.statusElem = document.getElementById(name + '-status');
                this.ioElem = document.getElementById(name + '-io');
                this.state = '';
                this.wasReady = false;

                this.process = new ProcessManager(name, name)
                this.process.setStatus = this.setStatus.bind(this);
                this.process.print = this.print.bind(this);
                this.process.printErr = this.printErr.bind(this);
            }

            reboot() {
                this.process.terminate();
                if (this.ioElem)
                    this.ioElem.textContent = '';
                this.process.start();
            }

            setStatus(state, status) {
                console.log(this.name, state + ':', status);
                this.statusElem.textContent = status;
                this.state = state;
                if (state == 'ready')
                    this.statusElem.style.color = 'green';
                else if (state == 'error')
                    this.statusElem.style.color = 'red';
                else
                    this.statusElem.style.color = 'blue';
                updateUI();
            };

            print({ text }) {
                if (this.ioElem)
                    this.ioElem.textContent += text + '\n';
                else
                    console.log(this.name, 'stdout:', text);
            };

            printErr({ text }) {
                if (this.ioElem)
                    this.ioElem.textContent += text + '\n';
                else
                    console.log(this.name, 'stderr:', text);
            };
        } // class ProcessUI

        let clangFormat = new ProcessUI('clang-format');
        let clang = new ProcessUI('clang');
        let runtime = new ProcessUI('runtime');
        let saveButton = document.getElementById('clang-save');
        let clangOutput = null;

        clangFormat.process.workerFormatDone = args => {
            clangFormat.process.setStatus('ready', 'Ready');
            formatEditor.setValue(args.result);
        };

        clang.process.print({ text: 'Preparing clang...\n\n' });
        clang.process.workerCompileDone = args => {
            if (args.result)
                clang.ioElem.textContent += 'wasm size: ' + args.result.length + '\n';
            clangOutput = args.result;
            clang.process.setStatus('ready', 'Ready');
        };

        runtime.process.print({ text: 'Preparing runtime...\n\n' });
        runtime.process.workerRunDone = args => {
            runtime.process.setStatus('ready', 'Ready');
        };
        runtime.process.workerDebugReplaceBinary = args => {
            clang.ioElem.textContent += 'new size:  ' + args.newBinary.length + '\n';
            clangOutput = args.newBinary;
            updateUI();
        };

        clangFormat.process.start();
        clang.process.start();
        runtime.process.start();

        function rebootClangFormat() {
            prevEditorContent = '';
            if (formatEditor)
                formatEditor.setValue('');
            clangFormat.reboot();
        }

        function compile() {
            if (clang.state !== 'ready')
                return;
            clangOutput = null;
            clang.process.setStatus('busy', 'Running');
            clang.ioElem.textContent = '';
            clang.process.worker.postMessage({
                function: 'compile',
                code: editor.getValue(),
            });
        }

        function saveWasm() {
            let blob = new Blob([clangOutput], {
                "type": "application/binary"
            });
            let a = document.createElement("a");
            a.download = 'user.wasm';
            a.href = URL.createObjectURL(blob);
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        function run() {
            runtime.ioElem.textContent = '';
            runtime.process.setStatus('busy', 'Running');
            runtime.process.worker.postMessage({
                function: 'run',
                wasmBinary: clangOutput,
            });
        }

        let currentGistID = '';
        async function loadGist(gistID) {
            if (gistID === currentGistID)
                return;
            if (!editor) {
                setTimeout(() => loadGist(gistID), 100);
                return;
            }
            currentGistID = gistID;
            try {
                let gistRequest = await fetch('https://api.github.com/gists/' + gistID);
                let gistJson = await gistRequest.json();
                if (gistRequest.status !== 200)
                    if (gistJson && gistJson.message)
                        throw new Error(gistJson.message);
                    else
                        throw new Error('an error occured')
                if (!('main.cpp' in gistJson.files))
                    throw new Error('main.cpp missing');
                let codeRequest = await fetch(gistJson.files['main.cpp'].raw_url);
                if (codeRequest.status !== 200)
                    throw new Error('an error occured')
                let text = await codeRequest.text();
                editor.executeEdits('gist', [{ identifier: 'delete', range: new monaco.Range(1, 1, 10000, 1), text: '', forceMoveMarkers: true }]);
                editor.executeEdits('gist', [{ identifier: 'insert', range: new monaco.Range(1, 1, 1, 1), text, forceMoveMarkers: true }]);
                editor.setSelection(new monaco.Range(0, 0, 0, 0));
            } catch (e) {
                clang.ioElem.textContent += '\ngist ' + gistID + ': ' + e.message + '\n';
            }
        }

        function handleHash() {
            for (let arg of window.location.hash.substr(1).split('&'))
                if (arg.startsWith('gist='))
                    loadGist(encodeURIComponent(arg.substr(5)));
        }
        handleHash();
        window.addEventListener("hashchange", handleHash, false);

        function updateUI() {
            let clangReady = editor && clang.state === 'ready';
            clang.runButton.disabled = !clangReady;
            saveButton.disabled = !clangOutput;
            if (clangReady && !clang.wasReady) {
                clang.wasReady = true;
                clang.ioElem.textContent = 'Click the compile button\n\n';
            }

            let runtimeReady = runtime.state === 'ready';
            runtime.runButton.disabled = !runtimeReady || !clangOutput;
            if (runtimeReady && !runtime.wasReady) {
                runtime.wasReady = true;
                runtime.ioElem.textContent = 'Click the compile button then the run button\n\n';
            }

            if (clangFormat.state === 'ready' && editorContent !== prevEditorContent && editor && formatEditor) {
                prevEditorContent = editorContent;
                clangFormat.process.setStatus('busy', 'Running');
                clangFormat.process.worker.postMessage({
                    function: 'format',
                    code: editor.getValue(),
                });
            }
        }
    </script>
</body>

</html>